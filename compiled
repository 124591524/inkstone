"use strict";

angular.module('makemeahanzi', ['ngRoute']).config(function ($routeProvider, $locationProvider) {
  $routeProvider.when('/character/:character', { templateUrl: 'character.html' }).otherwise({ templateUrl: 'search.html' });
});
"use strict";

var augmentTreeWithLabels = function augmentTreeWithLabels(node, dependencies) {
  var value = node.value;
  if (node.type === 'compound') {
    node.label = lower(decomposition_util.ids_data[value].label);
    node.children.map(function (child) {
      return augmentTreeWithLabels(child, dependencies);
    });
  } else {
    node.label = dependencies[node.value] || '(unknown)';
  }
};

var coerceToUnicode = function coerceToUnicode(character) {
  if (character.startsWith('&#') && character.endsWith(';')) {
    var char_code = parseInt(character.slice(2, character.length - 1), 10);
    return String.fromCharCode(char_code);
  }
  return character;
};

var constructTree = function constructTree(row) {
  var decomposition = row.decomposition;
  var tree = decomposition_util.convertDecompositionToTree(decomposition);
  augmentTreeWithLabels(tree, row.dependencies);
  return tree;
};

var formatEtymology = function formatEtymology(etymology) {
  var result = [etymology.type];
  if (etymology.type === 'ideographic' || etymology.type === 'pictographic') {
    if (etymology.hint) {
      result.push('- ' + lower(etymology.hint));
    }
  } else {
    result.push('-');
    result.push(etymology.semantic || '?');
    if (etymology.hint) {
      result.push('(' + lower(etymology.hint) + ')');
    }
    result.push('provides the meaning while');
    result.push(etymology.phonetic || '?');
    result.push('provides the pronunciation.');
  }
  return result.join(' ');
};

var getCharacterData = function getCharacterData($http, character, callback) {
  var part = Math.floor(character.charCodeAt(0) / 256);
  $http.get('data/part-' + part + '.txt').then(function (response) {
    var data = response.data;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = response.data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var row = _step.value;

        if (row.character === character) {
          return callback(row);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });
};

var lower = function lower(string) {
  if (string.length === 0) return string;
  return string[0].toLowerCase() + string.substr(1);
};

var DataController = function DataController($scope, $routeParams, $http) {
  var _this = this;

  this.character = coerceToUnicode($routeParams.character);
  this.decomposition = [];
  this.metadata = [];
  this.strokes = [];

  this._resize = function () {
    _this.short = window.innerWidth <= 480 ? 'short ' : '';
    _this.orientation = window.innerWidth < window.innerHeight ? 'vertical' : 'horizontal';
  };
  this._resize();

  this._refresh = function (row) {
    var short = window.innerWidth <= 480;
    _this.decomposition.push(constructTree(row));
    _this.metadata = [{ label: short ? 'Def.' : 'Definition:', value: row.definition }, { label: short ? 'Pin.' : 'Pinyin:', value: row.pinyin.join(', ') }, { label: short ? 'Rad.' : 'Radical:', value: row.radical }];
    if (row.etymology) {
      _this.metadata.push({
        label: short ? 'For.' : 'Formation:',
        value: formatEtymology(row.etymology)
      });
    }
    _this.strokes = row.strokes;
  };
  getCharacterData($http, this.character, this._refresh.bind(this));
};

angular.module('makemeahanzi').controller('DataController', DataController);
"use strict";

if (exports.decomposition_util !== undefined) {
  throw new Error('Redefining decomposition_util global!');
}
exports.decomposition_util = {};

decomposition_util.ids_data = {
  '⿰': { label: 'Left-to-right', arity: 2 },
  '⿱': { label: 'Top-to-bottom', arity: 2 },
  '⿴': { label: 'Surround', arity: 2 },
  '⿵': { label: 'Surround-from-above', arity: 2 },
  '⿶': { label: 'Surround-from-below', arity: 2 },
  '⿷': { label: 'Surround-from-left', arity: 2 },
  '⿸': { label: 'Surround-from-upper-left', arity: 2 },
  '⿹': { label: 'Surround-from-upper-right', arity: 2 },
  '⿺': { label: 'Surround-from-lower-left', arity: 2 },
  '⿻': { label: 'Overlaid', arity: 2 },
  '⿳': { label: 'Top-to-middle-to-bottom', arity: 3 },
  '⿲': { label: 'Left-to-middle-to-right', arity: 3 }
};
decomposition_util.ideograph_description_characters = Object.keys(decomposition_util.ids_data);

var UNKNOWN_COMPONENT = '？';

var assert = function assert(condition, message) {
  return condition || console.error(message);
};

var augmentTreeWithPathData = function augmentTreeWithPathData(tree, path) {
  tree.path = path;
  var children = (tree.children || []).length;
  for (var i = 0; i < children; i++) {
    augmentTreeWithPathData(tree.children[i], path.concat([i]));
  }
  return tree;
};

var parseSubtree = function parseSubtree(decomposition, index) {
  assert(index[0] < decomposition.length, 'Not enough characters in ' + decomposition + '.');
  var current = decomposition[index[0]];
  index[0] += 1;
  if (decomposition_util.ids_data.hasOwnProperty(current)) {
    var result = { type: 'compound', value: current, children: [] };
    for (var i = 0; i < decomposition_util.ids_data[current].arity; i++) {
      result.children.push(parseSubtree(decomposition, index));
    }
    return result;
  } else if (current === UNKNOWN_COMPONENT) {
    return { type: 'character', value: '?' };
  }
  // Characters may be followed by a [x] annotation that records which variant
  // of the character to use at that position. We ignore these annotations.
  if (decomposition[index[0]] === '[') {
    assert('0123456789'.indexOf(decomposition[index[0] + 1]) >= 0);
    assert(decomposition[index[0] + 2] === ']');
    index[0] += 3;
  }
  return { type: 'character', value: current };
};

var serializeSubtree = function serializeSubtree(subtree, result) {
  result[0] += subtree.value === '?' ? UNKNOWN_COMPONENT : subtree.value;
  var children = subtree.children ? subtree.children.length : 0;
  for (var i = 0; i < children; i++) {
    serializeSubtree(subtree.children[i], result);
  }
};

decomposition_util.collectComponents = function (tree, result) {
  result = result || [];
  if (tree.type === 'character' && tree.value !== '?') {
    result.push(tree.value);
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (tree.children || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var child = _step.value;

      decomposition_util.collectComponents(child, result);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
};

decomposition_util.convertDecompositionToTree = function (decomposition) {
  var index = [0];
  decomposition = decomposition || UNKNOWN_COMPONENT;
  var result = parseSubtree(decomposition, index);
  assert(index[0] === decomposition.length, 'Too many characters in ' + decomposition + '.');
  return augmentTreeWithPathData(result, []);
};

decomposition_util.convertTreeToDecomposition = function (tree) {
  var result = [''];
  serializeSubtree(tree, result);
  return result[0];
};

decomposition_util.getSubtree = function (tree, path) {
  var subtree = tree;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = path[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var index = _step2.value;

      assert(0 <= index && index < subtree.children.length);
      subtree = subtree.children[index];
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return subtree;
};
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = {
  distance2: function distance2(point1, point2) {
    return util.norm2(util.subtract(point1, point2));
  },
  norm2: function norm2(point) {
    return point[0] * point[0] + point[1] * point[1];
  },
  round: function round(point) {
    return point.map(Math.round);
  },
  subtract: function subtract(point1, point2) {
    return [point1[0] - point2[0], point1[1] - point2[1]];
  }
};

var coerce = function coerce(x, y) {
  return x == null ? y : x;
};

var filterMedian = function filterMedian(median, n) {
  var result = [];
  var total = 0;
  for (var i = 0; i < median.length - 1; i++) {
    total += Math.sqrt(util.distance2(median[i], median[i + 1]));
  }
  var index = 0;
  var position = median[0];
  var total_so_far = 0;
  for (var i = 0; i < n - 1; i++) {
    var target = i * total / (n - 1);
    while (total_so_far < target) {
      var step = Math.sqrt(util.distance2(position, median[index + 1]));
      if (total_so_far + step < target) {
        index += 1;
        position = median[index];
        total_so_far += step;
      } else {
        var t = (target - total_so_far) / step;
        position = [(1 - t) * position[0] + t * median[index + 1][0], (1 - t) * position[1] + t * median[index + 1][1]];
        total_so_far = target;
      }
    }
    result.push(util.round(position));
  }
  result.push(median[median.length - 1]);
  return result;
};

var getAffineTransform = function getAffineTransform(source, target) {
  var sdiff = util.subtract(source[1], source[0]);
  var tdiff = util.subtract(target[1], target[0]);
  var ratio = [tdiff[0] / sdiff[0], tdiff[1] / sdiff[1]];
  return function (point) {
    return [Math.round(ratio[0] * (point[0] - source[0][0]) + target[0][0]), Math.round(ratio[1] * (point[1] - source[0][1]) + target[0][1])];
  };
};

var getBounds = function getBounds(medians) {
  var min = [Infinity, Infinity];
  var max = [-Infinity, -Infinity];
  medians.map(function (median) {
    return median.map(function (point) {
      min[0] = Math.min(min[0], point[0]);
      min[1] = Math.min(min[1], point[1]);
      max[0] = Math.max(max[0], point[0]);
      max[1] = Math.max(max[1], point[1]);
    });
  });
  return [min, max];
};

var normalizeBounds = function normalizeBounds(bounds, max_ratio, min_width) {
  bounds = bounds.map(util.round);
  var diff = util.subtract(bounds[1], bounds[0]);
  if (diff[0] < 0 || diff[1] < 0) throw diff;
  if (diff[0] < min_width) {
    var extra = Math.ceil((min_width - diff[0]) / 2);
    bounds[0][0] -= extra;
    bounds[1][0] += extra;
  }
  if (diff[1] < min_width) {
    var extra = Math.ceil((min_width - diff[1]) / 2);
    bounds[0][1] -= extra;
    bounds[1][1] += extra;
  }
  if (max_ratio > 0) {
    diff = util.subtract(bounds[1], bounds[0]);
    if (diff[0] < diff[1] / max_ratio) {
      var extra = Math.ceil((diff[1] / max_ratio - diff[0]) / 2);
      bounds[0][0] -= extra;
      bounds[1][0] += extra;
    } else if (diff[1] < diff[0] / max_ratio) {
      var extra = Math.ceil((diff[0] / max_ratio - diff[1]) / 2);
      bounds[0][1] -= extra;
      bounds[1][1] += extra;
    }
  }
  return bounds;
};

var preprocessMedians = function preprocessMedians(medians, params) {
  if (medians.length === 0 || medians.some(function (median) {
    return median.length === 0;
  })) {
    throw new Error("Invalid medians list: " + JSON.stringify(medians));
  }

  var n = params.side_length;
  var source = normalizeBounds(getBounds(medians), params.max_ratio, params.min_width);
  var target = [[0, 0], [params.side_length - 1, params.side_length - 1]];
  var transform = getAffineTransform(source, target);

  return medians.map(function (median) {
    var result = filterMedian(median.map(transform), params.points);
    var diff = util.subtract(result[result.length - 1], result[0]);
    var angle = Math.atan2(diff[1], diff[0]);
    var normalized = Math.round((angle + Math.PI) * n / (2 * Math.PI)) % n;
    var length = Math.round(Math.sqrt(util.norm2(diff) / 2));
    return [].concat.apply([], result).concat([normalized, length]);
  });
};

var scoreMatch = function scoreMatch(source, target, params, verbose) {
  var score = 0;
  var n = params.points;
  for (var i = 0; i < source.length; i++) {
    var median1 = source[i];
    var median2 = target[i];
    for (var j = 0; j < n; j++) {
      score -= Math.abs(median1[2 * j] - median2[2 * j]);
      score -= Math.abs(median1[2 * j + 1] - median2[2 * j + 1]);
    }
    var angle = Math.abs(median1[2 * n] - median2[2 * n]);
    var ratio = (median1[2 * n + 1] + median2[2 * n + 1]) / params.side_length;
    score -= 4 * n * ratio * Math.min(angle, params.side_length - angle);
  }
  return score;
};

// A class that can be instantiated with a list of (character, median) pairs
// and then used to return closest character given a list of input strokes.

exports.Matcher = function () {
  function Matcher(medians, params) {
    _classCallCheck(this, Matcher);

    params = params || {};
    params.points = coerce(params.points, 4);
    params.max_ratio = coerce(params.max_ratio, 1);
    params.min_width = coerce(params.max_width, 8);
    params.side_length = coerce(params.side_length, 256);

    this._medians = medians;
    this._params = params;
  }

  _createClass(Matcher, [{
    key: "match",
    value: function match(medians, n) {
      n = n || 1;
      var candidates = [];
      var scores = [];
      medians = this.preprocess(medians);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._medians[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;

          if (entry[1].length !== medians.length) {
            continue;
          }
          var score = scoreMatch(medians, entry[1], this._params);
          var i = scores.length;
          while (i > 0 && score > scores[i - 1]) {
            i -= 1;
          }
          if (i < n) {
            candidates.splice(i, 0, entry[0]);
            scores.splice(i, 0, score);
            if (candidates.length > n) {
              candidates.pop();
              scores.pop();
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return candidates;
    }
  }, {
    key: "preprocess",
    value: function preprocess(medians) {
      return preprocessMedians(medians, this._params);
    }
  }]);

  return Matcher;
}();
"use strict";

// Helper methods used to decode data and build data structures follow.

// Given binary median data and an offset, returns a pair:
//   [character, medians]: the Matcher entry at that offset
//   index: the index starting the next entry.

var decodeMedian = function decodeMedian(buffer, i) {
  var character = String.fromCodePoint(buffer[i] + (buffer[i + 1] << 8));
  var medians = [];
  var num_medians = buffer[i + 2];
  i += 3;
  for (var j = 0; j < num_medians; j++) {
    var length = buffer[i];
    if (buffer.slice) {
      medians.push(buffer.slice(i + 1, i + length + 1));
    } else {
      var median = [];
      for (var k = 0; k < length; k++) {
        median.push(buffer[i + k + 1]);
      }
      medians.push(median);
    }
    i += length + 1;
  }
  return [[character, medians], i];
};

// Methods that return promises follow.

// Returns a Promise which resolves to an ArrayBuffer containing the data.
var loadBinaryData = function loadBinaryData(url) {
  return new Promise(function (resolve, reject) {
    var request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function (event) {
      if (request.status != 200) throw req;
      resolve(new Uint8Array(request.response));
    };
    request.send(null);
  });
};

// Returns a Promise that resolves to a list of (character, medians) pairs.
var decodeMedians = function decodeMedians(buffer) {
  var result = [];
  var decoded = null;
  for (var i = 0; i < buffer.length;) {
    var decoded = decodeMedian(buffer, i);
    result.push(decoded[0]);
    i = decoded[1];
  }
  return result;
};

// Returns a Promise that resolves to a list of [character, medians] pairs,
// where [medians] is a preprocessed Matcher entry for that character.
exports.mediansPromise = loadBinaryData('medians.bin').then(decodeMedians).catch(console.err);
"use strict";

var createSketch = function createSketch($scope, controller, canvas, svg) {
  var _mousedown = false;
  Sketch.create({
    container: canvas,
    autoclear: false,
    fullscreen: false,
    width: svg.clientWidth,
    height: svg.clientHeight,
    keydown: function keydown(e) {
      if (this.keys.C) {
        $scope.$apply(function () {
          _mousedown = false;
          controller.clear();
        });
      }
    },
    mousedown: function mousedown(e) {
      $scope.$apply(function () {
        _mousedown = true;
        controller.push_point([e.x, e.y]);
      });
    },
    mouseup: function mouseup(e) {
      $scope.$apply(function () {
        _mousedown = false;
        controller.end_stroke();
      });
    },
    touchmove: function touchmove() {
      var _this = this;

      if (_mousedown && this.touches.length > 0) {
        $scope.$apply(function () {
          var touch = _this.touches[0];
          controller.maybe_push_point([touch.ox, touch.oy]);
          controller.push_point([touch.x, touch.y]);
        });
      }
    }
  });
};

var SearchController = function SearchController($scope) {
  var _this2 = this;

  var container = document.querySelector('#search #wrapper');

  this.strokes = [];
  this.stroke = function () {
    return _this2._d(_this2._stroke);
  };
  this.candidates = [];

  this.getURL = function (character) {
    return '#/character/' + character;
  };

  this._zoom = function () {
    var wrapper = container.parentElement;
    var x_zoom = wrapper.clientWidth / container.clientWidth;
    var y_zoom = wrapper.clientHeight / container.clientHeight;
    return Math.min(x_zoom, y_zoom);
  };
  this.zoom = this._zoom();

  this._stroke = [];
  this._strokes = [];
  this._matcher = null;

  window.mediansPromise.then(function (medians) {
    _this2._matcher = new Matcher(medians);
  }).catch(console.error.bind(console));

  this._d = function (path) {
    if (path.length < 2) return '';
    var result = [];
    var point = function point(i) {
      return path[i][0] + ' ' + path[i][1];
    };
    var midpoint = function midpoint(i) {
      return (path[i][0] + path[i + 1][0]) / 2 + ' ' + ('' + (path[i][1] + path[i + 1][1]) / 2);
    };
    var push = function push(x) {
      return result.push(x);
    };
    ['M', point(0), 'L', midpoint(0)].map(push);
    for (var i = 1; i < path.length - 1; i++) {
      ['Q', point(i), midpoint(i)].map(push);
    }
    ['L', point(path.length - 1)].map(push);
    return result.join(' ');
  };
  this._refresh_candidates = function () {
    if (_this2._strokes.length > 0 && _this2._matcher) {
      _this2.candidates = _this2._matcher.match(_this2._strokes, 8);
    } else {
      _this2.candidates = [];
    }
  };

  this.clear = function () {
    _this2.strokes = [];
    _this2._stroke = [];
    _this2._strokes = [];
    _this2._refresh_candidates();
    _this2.candidates = [];
  };
  this.end_stroke = function () {
    if (_this2._stroke.length > 1) {
      _this2.strokes.push(_this2._d(_this2._stroke));
      _this2._strokes.push(_this2._stroke);
      _this2._stroke = [];
      _this2._refresh_candidates();
    }
  };
  this.maybe_push_point = function (point) {
    if (_this2._stroke.length === 0) {
      _this2.push_point(point);
    }
  };
  this.push_point = function (point) {
    if (point[0] != null && point[1] != null) {
      _this2._stroke.push(point.map(function (x) {
        return x / _this2.zoom;
      }));
    }
  };
  this.undo = function () {
    _this2.strokes.pop();
    _this2._strokes.pop();
    _this2._stroke = [];
    _this2._refresh_candidates();
  };

  var canvas = container.querySelector('.handwriting .input');
  var svg = container.querySelector('.handwriting svg');
  createSketch($scope, this, canvas, svg);
};

angular.module('makemeahanzi').controller('SearchController', SearchController);

